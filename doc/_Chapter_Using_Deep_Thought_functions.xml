<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Using_Deep_Thought_functions">
<Heading>Using Deep Thought functions</Heading>

In the following sections, functions provided for computing Deep Thought polynomials and using them for calculations are listed.
<Section Label="Chapter_Using_Deep_Thought_functions_Section_Computing_Deep_Though_polynomials">
<Heading>Computing Deep Though polynomials</Heading>

<ManSection>
  <Func Arg="coll" Name="DTP_DTapplicability" />
 <Returns>boolean
</Returns>
 <Description>
Checks the collector <C>coll</C> for applicability of Deep Thought functions. Note that depending on consistency some functions may be applicable, while others are not. Information on the applicability and which type of Deep Thought polynomials are suggested is printed to the terminal. Here, "+" means that the following property is fulfilled, otherwise there is a "-". The function returns <C>false</C> if Deep Thought is not applicable to the collector <C>coll</C> and <C>true</C> otherwise. Anyway, even if <C>true</C> is returned, <Emph>not all functions need to be applicable</Emph> (in case of inconsistenies).
 </Description>
</ManSection>


<ManSection>
  <Func Arg="coll, [, rs_flag]" Name="DTP_DTObjFromCollector" />
 <Returns>a DTObj
</Returns>
 <Description>
Computes a DTObj for the collector coll, either with polynomials of type <Math>f_{rs}</Math> (if <C>rs_flag = true</C>) or with polynomials of type <Math>f_r</Math>, otherwise. If the optional argument <C>rs_flag</C> is not provided, polynomials of type <Math>f_{rs}</Math> are computed. The function checks whether the collector <C>coll</C> is confluent. If not, a warning is displayed. Note that the functions assumes the collector <C>coll</C> to be suitable for Deep Thought, see function <C>DTP_DTapplicability</C>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> G := UnitriangularPcpGroup(10, 0);; 
gap> coll := Collector(G);; 
gap> DTP_DTapplicability(coll); 
Checking collector for DT-applicability. "+" means the following property
is fulfilled.
+   conjugacy relations
+   power relations
+   consistent
Suggestion: Call DTP_DTObjFromColl with rs_flag = true.
true
# calling DTP_DTObjFromCollector without rs_flag implies rs_flag = true: 
gap> DTObj := DTP_DTObjFromCollector(coll);
<DTObj>
]]></Example>


</Section>


<Section Label="Chapter_Using_Deep_Thought_functions_Section_Computations_with_Deep_Thought_polynomials">
<Heading>Computations with Deep Thought polynomials</Heading>

<ManSection>
  <Func Arg="expvec, int, DTObj" Name="DTP_Exp" />
 <Returns>an exponent vector
</Returns>
 <Description>
Computes the exponent vector of <C>expvec</C><Math>^{int}</Math>. If <C>DTObj![PC_DTPConfluent] = true</C>, then the result is in normal form.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="expvec, DTObj" Name="DTP_Inverse" />
 <Returns>an exponent vector
</Returns>
 <Description>
Computes the exponent vector of the inverse of the element corresponding to <C>expvec</C>. If <C>DTObj![PC_DTPConfluent] = true</C>, then the result describes a normal form.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="expvec, coll" Name="DTP_IsInNormalForm" />
 <Returns>boolean or positive integer
</Returns>
 <Description>
Checks whether <C>expvec</C> is in normal form or not. If yes, the return value is <C>true</C>. Otherwise the return value is the smallest generator index for which the normal form condition is violated, i.e. for which the relative order <C>RelativeOrder(coll)[i]</C> is non-zero, and <C>expvec[i]</C> &lt; <C>0</C> or <C>expvec[i]</C> <Math>\geq</Math> <C>RelativeOrder(coll)[i]</C>.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="expvec1, expvec2, DTObj" Name="DTP_Multiply" />
 <Returns>an exponent vector
</Returns>
 <Description>
Computes the exponent vector of the product <C>expvec1 * expvec2</C> using the Deep Thought polynomials. If <C>DTObj![PC_DTPConfluent] = true</C>, then the result is returned in normal form.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="arg" Name="DTP_Multiply_r" />
 <Returns></Returns>
 <Description>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="arg" Name="DTP_Multiply_rs" />
 <Returns></Returns>
 <Description>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="expvec, DTObj" Name="DTP_NormalForm" />
 <Returns>an exponent vector
</Returns>
 <Description>
Computes the exponent vector of the normal form of <C>expvec</C>. For this function to be applicable, we need <C>DTObj![PC_DTPConfluent] = true</C>.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="expvec, DTObj" Name="DTP_Order" />
 <Returns>positive integer or infinity
</Returns>
 <Description>
Computes the order of the element described by <C>expvec</C>. For this function to be applicable, we need <C>DTObj![PC_DTPConfluent] = true</C>.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="expvec1, expvec2, DTObj" Name="DTP_SolveEquation" />
 <Returns>an exponent vector
</Returns>
 <Description>
Computes the exponent vector of the element corresponding to <C>expvec1</C><Math>^{-1}</Math> <C>* expvec2</C>, i.e. the result solves the equation <C>expvec1 * result = expvec2</C>. If <C>DTObj![PC_DTPConfluent] = true</C>, then the result
describes a normal form.
 </Description>
</ManSection>


<Example><![CDATA[
gap> G := PcGroupToPcpGroup(SmallGroup(23^5, 2)); 
Pcp-group with orders [ 23, 23, 23, 23, 23 ]
gap> coll := Collector(G); 
<<from the left collector with 5 generators>>
gap> DTObj := DTP_DTObjFromCollector(coll); 
<DTObj>
gap> g := [100, 134, -31, 52, 5235]; 
[ 100, 134, -31, 52, 5235 ]
gap> DTP_IsInNormalForm(g, DTObj); 
1
gap> g := DTP_NormalForm(g, DTObj);
[ 8, 19, 15, 10, 19 ]
gap> DTP_IsInNormalForm(g, DTObj);         
true
gap> DTP_Inverse(g, DTObj); 
[ 15, 4, 22, 12, 3 ]
gap> DTP_Order(g, DTObj);
529
gap> h := [142, 2, -41, 23, 1]; 
[ 142, 2, -41, 23, 1 ]
gap> DTP_Multiply(g, h, DTObj); 
[ 12, 21, 4, 16, 20 ]
]]></Example>


</Section>


<Section Label="Chapter_Using_Deep_Thought_functions_Section_Computations_with_pcp-elements">
<Heading>Computations with pcp-elements</Heading>

When Deep Thought polynomials are available, certain computations allow different approaches which may be faster than the methods used by default.
In this sections, computations for which such extra functions taking pcp-elements as input are available are listed. All of these functions expect the collector belonging to the pcp-elements to be a <C>DTObj</C>.
<ManSection>
  <Func Arg="pcp-element, int" Name="DTP_PCP_Exp" />
 <Returns>pcp-element
</Returns>
 <Description>
Returns the pcp-element <C>pcp-element</C><Math>^{\text{int}}</Math>. If <C>DTObj![PC_DTPConfluent] = true</C>, then the result is in normal form.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="pcp-element" Name="DTP_PCP_Inverse" />
 <Returns>pcp-element
</Returns>
 <Description>
Returns the pcp-elment <C>pcp-element^-1</C>. If <C>DTObj![PC_DTPConfluent] = true</C>, then the result describes a normal form.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="pcp-element" Name="DTP_PCP_NormalForm" />
 <Returns>pcp-element
</Returns>
 <Description>
Returns a pcp-element which is the normal form of the input pcp-element. For this function to be applicable, we need <C>DTObj![PC_DTPConfluent] = true</C>.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="pcp-element" Name="DTP_PCP_Order" />
 <Returns>positive integer or infinity
</Returns>
 <Description>
Computes the order of the pcp-element. For this function to be applicable, we need <C>DTObj![PC_DTPConfluent] = true</C>.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="pcp-element1, pcp-element2" Name="DTP_PCP_SolveEquation" />
 <Returns>pcp-element
</Returns>
 <Description>
Returns the pcp-element <C>pcp-element1</C><Math>^{-1}</Math> <C>* pcp-element2</C>, i.e. the result solves the equation <C>pcp-element1 * pcp-element = pcp-element2</C>. If <C>DTObj![PC_DTPConfluent] = true</C>, then the result
describes a normal form.
 </Description>
</ManSection>


<Example><![CDATA[
gap> G := HeisenbergPcpGroup(7);;
gap> coll := Collector(G);;
gap> DTObj := DTP_DTObjFromCollector(coll);;
gap> H := PcpGroupByCollector(DTObj);;
gap> g := Random(H);; h := Random(H);; 
gap> DTP_PCP_SolveEquation(g, h); 
g1^-3*g2^-1*g3^-7*g4*g5^-6*g6*g7*g8^2*g9^3*g11^-4*g12^5*g14^-2*g15^7
gap> g^-1 * h; 
g1^-3*g2^-1*g3^-7*g4*g5^-6*g6*g7*g8^2*g9^3*g11^-4*g12^5*g14^-2*g15^7
gap> Order(g); 
infinity
gap> g^-1; 
g1^-2*g3^-3*g4^-1*g5^-4*g6^2*g7*g8^-3*g10^-3*g11^-1*g12^4*g14^-2*g15^-3
gap> DTP_PCP_Inverse(h); 
g1*g2*g3^4*g4^-2*g5^2*g6*g8^-5*g9^-3*g10^-3*g11^3*g12^-1*g15^-33
]]></Example>


</Section>


<Section Label="Chapter_Using_Deep_Thought_functions_Section_Accessing_Deep_Thought_polynomials">
<Heading>Accessing Deep Thought polynomials</Heading>

In this sections, functions which can be used to display the content of a <C>DTObj</C> are documented. Furthermore, Deep Thought polynomials stored in a <C>DTObj</C> can be converted to &GAP; polynomials.
<ManSection>
  <Func Arg="DTObj" Name="DTP_Display_DTObj" />
 <Returns>nothing
</Returns>
 <Description>
Prints information about <C>DTObj</C> to the terminal. In particular, the Deep Thought polynomials are printed in human-readable form. This function is also called by the method of Display for a DTObj.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="DTObj" Name="DTP_pols2GAPpols" />
 <Returns>list
</Returns>
 <Description>
Converts the Deep Thought polynomials stored in <C>DTObj[PC_DTPPolynomials]</C> to &GAP; polynomials and returns them in a list together with their polynomial ring.
 </Description>
</ManSection>


<Example><![CDATA[
gap> coll := FromTheLeftCollector(4);;
gap> SetConjugate(coll, 2, 1, [2, 1, 3, 2]);      
gap> SetConjugate(coll, 3, 1, [3, 1, 4, 1]);      
gap> SetConjugate(coll, 3, 2, [3, 1, 4, 5]);      
gap> UpdatePolycyclicCollector(coll);      
gap> DTObj := DTP_DTObjFromCollector(coll); 
<DTObj>
gap> Display(DTObj); 
Polynomials f_rs for s = 1:
f_1,s = X_1 + Y_1 
f_2,s = X_2 
f_3,s = X_3 + 2 * X_2 Y_1 
f_4,s = X_4 + X_3 Y_1 + 2 * X_2 Binomial(Y_1, 2) + 10 * Binomial(X_2, 2) Y_1 
Polynomials f_rs for s = 2:
f_1,s = X_1 
f_2,s = X_2 + Y_2 
f_3,s = X_3 
f_4,s = X_4 + 5 * X_3 Y_2 
Polynomials f_rs for s = 3:
f_1,s = X_1 
f_2,s = X_2 
f_3,s = X_3 + Y_3 
f_4,s = X_4 
Polynomials f_rs for s = 4:
f_1,s = X_1 
f_2,s = X_2 
f_3,s = X_3 
f_4,s = X_4 + Y_4 
gap> DTObj := DTP_DTObjFromCollector(coll, false);
<DTObj>
gap> Display(DTObj);                              
f_1 = X_1 + Y_1 
f_2 = X_2 + Y_2 
f_3 = X_3 + Y_3 + 2 * X_2 Y_1 
f_4 = X_4 + Y_4 + X_3 Y_1 + 2 * X_2 Binomial(Y_1, 2) + 
10 * Binomial(X_2, 2) Y_1 + 5 * X_3 Y_2 + 10 * X_2 Y_1 Y_2 
gap> DTP_pols2GAPpols(DTObj);
 [ [ x1+y1, x2+y2, 2*x2*y1+x3+y3, 
5*x2^2*y1+x2*y1^2+10*x2*y1*y2-6*x2*y1+x3*y1+5*x3*y2+x4+y4 ], 
Rationals[x1,x2,x3,x4,y1,y2,y3,y4] ]
]]></Example>


</Section>


</Chapter>

